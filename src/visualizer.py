# visualizer.py
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from matplotlib.patches import Circle
import numpy as np

def parse_output(filename):
    """
    Parses the output file generated by the main algorithm.
    Returns: robots_data dictionary, makespan
    """
    robots_data = {}
    with open(filename, 'r') as f:
        lines = f.readlines()
    
    makespan_ms = float(lines[0].strip())
    makespan = makespan_ms / 1000.0  # Convert to seconds

    index = 1
    while index < len(lines):
        line = lines[index].strip()
        if line.startswith('R'):
            # This is a robot header line: "R1 15"
            parts = line.split()
            robot_id = parts[0]
            num_waypoints = int(parts[1])
            
            times = []
            x_pos = []
            y_pos = []
            z_pos = []
            
            # Read the next 'num_waypoints' lines
            for i in range(1, num_waypoints + 1):
                data_line = lines[index + i].split()
                t = float(data_line[0]) / 1000.0  # ms -> seconds
                x = float(data_line[1])
                y = float(data_line[2])
                z = float(data_line[3])
                times.append(t)
                x_pos.append(x)
                y_pos.append(y)
                z_pos.append(z)
            
            robots_data[robot_id] = {
                'times': np.array(times),
                'x': np.array(x_pos),
                'y': np.array(y_pos),
                'z': np.array(z_pos)
            }
            index += num_waypoints + 1  # Move index to the next robot header
        else:
            index += 1

    return robots_data, makespan

def get_position_at_time(robot_data, t):
    """
    Gets the (x, y) position of a robot at time t by interpolating between waypoints.
    Returns a tuple (x, y) which is a valid sequence.
    """
    times = robot_data['times']
    x_vals = robot_data['x']
    y_vals = robot_data['y']
    
    # If time is before first waypoint, return first position
    if t <= times[0]:
        return (x_vals[0], y_vals[0]) # FIX: Return a tuple
    # If time is after last waypoint, return last position
    if t >= times[-1]:
        return (x_vals[-1], y_vals[-1]) # FIX: Return a tuple
    
    # Find the index where the time would be inserted (finds the segment)
    idx = np.searchsorted(times, t) - 1
    # Linear interpolation
    t_start, t_end = times[idx], times[idx+1]
    x_start, x_end = x_vals[idx], x_vals[idx+1]
    y_start, y_end = y_vals[idx], y_vals[idx+1]
    
    frac = (t - t_start) / (t_end - t_start)
    x = x_start + frac * (x_end - x_start)
    y = y_start + frac * (y_end - y_start)
    return (x, y) # This was already correct

# --- Main Visualization Function ---
def animate_simulation(output_file='output.txt', tool_clearance=0.2, safe_dist=0.1):
    """
    Creates an animation from the output.txt file.
    """
    robots_data, makespan = parse_output(output_file)
    # Handle case where makespan is 0 to avoid division by zero
    if makespan <= 0:
        makespan = 1.0
        
    robot_ids = list(robots_data.keys())
    colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown'] 
    
    fig, ax = plt.subplots(figsize=(10, 8))
    ax.set_xlabel('X Position')
    ax.set_ylabel('Y Position')
    ax.set_title('Multi-Robot Simulation')
    ax.grid(True)
    ax.set_aspect('equal')
    
    # Plot static paths first
    for idx, robot_id in enumerate(robot_ids):
        data = robots_data[robot_id]
        ax.plot(data['x'], data['y'], color=colors[idx], alpha=0.3, linestyle='-', label=f'{robot_id} Path')
    
    # Create moving elements (dots for robots, circles for safety zones)
    robot_dots = []
    safety_circles = []
    for idx, robot_id in enumerate(robot_ids):
        # Initialize with empty lists, not empty values
        dot, = ax.plot([], [], 'o', color=colors[idx], markersize=8, markeredgecolor='black')
        robot_dots.append(dot)
        circle = Circle((0, 0), radius=tool_clearance + safe_dist/2, fill=False, color=colors[idx], linestyle='--', alpha=0.8)
        ax.add_patch(circle)
        safety_circles.append(circle)
    
    time_text = ax.text(0.02, 0.95, '', transform=ax.transAxes, fontsize=12)
    status_text = ax.text(0.02, 0.90, 'Status: OK', transform=ax.transAxes, fontsize=12, color='green')
    
    ax.legend(loc='upper right')
    
    def animation_frame(t):
        current_positions = []
        status_ok = True
        min_separation = float('inf')
        
        # Update each robot's position
        for idx, robot_id in enumerate(robot_ids):
            pos = get_position_at_time(robots_data[robot_id], t)
            x, y = pos
            # set_data expects sequences (lists/arrays), so we wrap x and y in lists
            robot_dots[idx].set_data([x], [y]) 
            safety_circles[idx].center = (x, y)
            current_positions.append((x, y))
        
        # Check for collisions
        for i in range(len(current_positions)):
            for j in range(i+1, len(current_positions)):
                x1, y1 = current_positions[i]
                x2, y2 = current_positions[j]
                distance = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
                min_separation = min(min_separation, distance)
                required_distance = tool_clearance + safe_dist + tool_clearance
                if distance < required_distance:
                    status_ok = False
                    robot_dots[i].set_color('black')
                    robot_dots[j].set_color('black')
                else:
                    # Make sure color is reset if no collision
                    if robot_dots[i].get_color() == 'black':
                        robot_dots[i].set_color(colors[i])
                    if robot_dots[j].get_color() == 'black':
                        robot_dots[j].set_color(colors[j])
        
        # status text
        if status_ok:
            status_text.set_text(f'Status: OK (Min Separation: {min_separation:.3f})')
            status_text.set_color('green')
        else:
            status_text.set_text('Status: COLLISION!')
            status_text.set_color('red')
        # timer
        time_text.set_text(f'Time: {t:.2f}s / {makespan:.2f}s')
        
        return robot_dots + safety_circles + [time_text, status_text]
    
    # Create the animation
    fps = 20
    frames = np.linspace(0, makespan, int(fps * makespan))
    
    if len(frames) == 0:
        frames = [0]
        

    ani = FuncAnimation(fig, animation_frame, frames=frames, interval=1000/fps, blit=False, repeat=False)
    
    plt.show()
    ani.save('robot_simulation.mp4', writer='ffmpeg', fps=fps, dpi=120, bitrate=500)

if __name__ == "__main__":
    animate_simulation('output.txt', tool_clearance=0.2, safe_dist=0.1)